变量
-----------------

变量是占位符,而占位符不一定是变量.

变量是此插件有关机制的最难的内容,您可以设置变量以存储数值或字符  
也可以设置变量以存储其它变量的值,所设置的变量可以是暂时的.

变量类型
-----------------

变量有3种类型.

| **类型** | **描述**                  |
|----------|----------------------------------|
| INTEGER  | 整数. |
| FLOAT    | 整数(支持小数) |
| STRING   | 字符 |

当类型为Integer或Float时,变量值只能是数值.  
但在[setVariable](/技能/变量/setvariable)时  
变量值可以是 变量值为纯数字(可包含运算符号)的占位符.

当类型为String时,变量值没有任何限制.
但在[setVariable](/技能/变量/setvariable)时
若变量值填写 其它类型为Integer或Float的变量  
所设置变量的值将会是 其它类型为Integer或Float的变量 的变量名,而不是变量名  
若变量值填写 其它类型为String的变量,所设置变量的值将包含 其它类型为String的变量 的变量名

讲解
-----------------

      Skills:
      - setvariable{var=caster.变量A;type=float;value="1"} @self
      - setvariable{var=caster.变量B;type=string;value="<caster.var.变量A>"} @self

激活上述技能组之后,变量B的值将为"<caster.var.变量A>",而不是"1",因为在设置变量B时  
变量值为 类型为Float的变量A的变量名 而不是 类型为Float的变量A的变量值.

若这么写,变量B的变量值将会变为"1",而不是上述的"<caster.var.变量A>":

      Skills:
      - setvariable{var=caster.变量A;type=string;value="1"} @self
      - setvariable{var=caster.变量B;type=string;value="<caster.var.变量A>"} @self

相同,Integer与Float类型的变量无法读取与 <target.name> 一样,变量值为非纯数字的变量.

### 变量种类

变量有4种种类:

| **种类** | **描述**                                                                                  |
|----------|----------------------------------------------------------------------------------------------------|
| SKILL    | 作用于技能组 |
| CASTER   | 作用于施法者                                                                                |
| TARGET   | 作用于技能目标                                       |
| WORLD    | 作用于世界                                                                                 |
| GLOBAL   | 作用于服务器                                                                               |

且在使用[setVariable](/技能/变量/setvariable)时就确定好了  
变量种类,变量种类的作用有俩种:  

-  配合占位符: [<变量种类.var.变量名>](/技能/占位符) 时,变量应该读取谁身上的变量
-  配合技能: [setVariable](/技能/变量/setvariable)时,变量应该存储在谁身上.

讲解
-----------------
     
    某技能组:
      Skills:
      - setvariable{var=caster.变量A;type=float;value="1"} @self
      - setvariable{var=target.变量B;type=float;value=<caster.var.变量A>} @target

施法者A将自身当前目标身上的 变量B 的值设为"1"

为何变量B在自身当前目标身上?  
因为设置变量B时scope(变量名的前缀)为target,target作用于技能目标,而技能目标就是@target,也就是自身当前目标.

为何变量B的值为"1"?  
因为设置变量B时value填写了 <caster.var.变量A>,也就是所设置变量的值为 施法者身上的变量A的值.

当激活此技能组后,当前目标作为另一个施法者时,所设置的变量如何调用?  
使用占位符: <caster.var.变量B>是因为之前施法者A将变量设置到了"target"身上  
(为何在target身上请看第一个解答) 而现在,"target"作为一个施法者,应该在调用  
变量B时将scope(变量名前缀)设为caster,以确认要调用的变量是自己身上的.

### Usage

All variable mechanics and conditions accept **var=** and **scope=**
attributes to determine what variable you're wanting to work with and
where. You can also shorthand the scope using
**var=scope.variable\_name**. The following examples would return the
same thing:

    setvariable{var=target.somevariable; ...}
    setvariable{var=somevariable;scope=target; ...}

### Variable Mechanics

Variable mechanics are special mechanics that utilize variables. They
can target entities, locations, or nothing, but the target can affect
the outcome depending on what scope you're using. For example, trying to
get a target-scope'd variable will obviously fail if you're not
targeting en entity.

| Mechanic                                               | Description                                      |
|--------------------------------------------------------|--------------------------------------------------|
| [VariableSet](/skills/mechanics/setvariable)           | Initializes and sets a variable.                 |
| [VariableAdd](/skills/mechanics/variableadd)           | Adds to a numeric variable.                      |
| [VariableSubtract](/skills/mechanics/variablesubtract) | Subtracts from a numeric variable.               |
| [VariableMath](/skills/mechanics/variablemath)         | Lets you do calculations with numeric variables. |

### Variable Conditions

| Condition                                        | Description                                    |
|--------------------------------------------------|------------------------------------------------|
| [Variable Equals](/conditions/variableequals)    | Checks if a variable equals a given value.     |
| [Variable Is Set](/conditions/variableisset)     | Checks if a variable is set.                   |
| [Variable In Range](/conditions/variableinrange) | Checks if a number variable is within a range. |

### Variable Placeholders

Variables can be referenced in any MythicMobs mechanics or values that
allow placeholders. This is usually done using the format
**&lt;scope.var.\[variable\]&gt;**.

When using placeholder variables, you can also specify a "default" value
that will be used if the variable is undefined by using the syntax
**&lt;scope.var.\[variable\]\|\[default\]&gt;**.

    message{m="Hello there, <target.var.title|wanderer>"} @trigger ~onInteract

In this example, the NPC would reply with "Hello there, wanderer" if
right-clicked by somebody who had no "title" variable set on them.
However, if we did this:

    setVariable{var=target.title;value="Sir"} @trigger ~onInteract

...somewhere along the line, even with a different mob, the first mob
would say "Hello there, Sir".